<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Peter Feiler">
  <meta name="author" content="Julien Delange">
  <title>Resolute Reference Guide</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="/home/kfhoech/git/smaccm/fm-workbench/resolute/org.osate.resolute.help/css/pandoc.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Resolute Reference Guide</h1>
<p class="author">Peter Feiler</p>
<p class="author">Julien Delange</p>
</header>
<nav id="TOC">
<ul>
<li><a href="#sec:introduction"><span class="toc-section-number">1</span> Introduction</a></li>
<li><a href="#sec:claim-functions"><span class="toc-section-number">2</span> Claim Functions</a><ul>
<li><a href="#sec:application-of-claim-functions"><span class="toc-section-number">2.1</span> Application of Claim Functions</a></li>
<li><a href="#sec:uses-of-claim-functions"><span class="toc-section-number">2.2</span> Uses of Claim Functions</a></li>
</ul></li>
<li><a href="#sec:computational-functions-and-constants"><span class="toc-section-number">3</span> Computational Functions and Constants</a><ul>
<li><a href="#sec:computational-functions"><span class="toc-section-number">3.1</span> Computational Functions</a></li>
<li><a href="#sec:global-constants"><span class="toc-section-number">3.2</span> Global Constants</a></li>
<li><a href="#sec:local-constants"><span class="toc-section-number">3.3</span> Local Constants</a></li>
</ul></li>
<li><a href="#sec:predicate-expressions-and-computational-expressions"><span class="toc-section-number">4</span> Predicate Expressions and Computational Expressions</a><ul>
<li><a href="#sec:predicate-expressions"><span class="toc-section-number">4.1</span> Predicate Expressions</a></li>
<li><a href="#sec:computational-expressions"><span class="toc-section-number">4.2</span> Computational Expressions</a><ul>
<li><a href="#sec:type-related-operators"><span class="toc-section-number">4.2.1</span> Type-related operators</a></li>
<li><a href="#sec:atomic-expressions"><span class="toc-section-number">4.2.2</span> Atomic expressions</a></li>
<li><a href="#sec:collection-related-operators"><span class="toc-section-number">4.2.3</span> Collection-related operators</a></li>
<li><a href="#sec:the-fail-expression"><span class="toc-section-number">4.2.4</span> The <code>fail</code> expression</a></li>
</ul></li>
</ul></li>
<li><a href="#sec:resolute-type-system"><span class="toc-section-number">5</span> Resolute Type System</a><ul>
<li><a href="#sec:built-in-base-types"><span class="toc-section-number">5.1</span> Built-in Base Types</a></li>
<li><a href="#sec:arithmetic-with-integers-and-reals"><span class="toc-section-number">5.2</span> Arithmetic with Integers and Reals</a></li>
<li><a href="#sec:aadl-model-element-types"><span class="toc-section-number">5.3</span> AADL Model Element Types</a></li>
</ul></li>
<li><a href="#sec:built-in-functions"><span class="toc-section-number">6</span> Built-in Functions</a><ul>
<li><a href="#sec:built-in-functions-for-collections"><span class="toc-section-number">6.1</span> Built-in Functions for Collections</a></li>
<li><a href="#sec:built-in-functions-for-ranges"><span class="toc-section-number">6.2</span> Built-in Functions for Ranges</a></li>
<li><a href="#sec:built-in-functions-for-properties"><span class="toc-section-number">6.3</span> Built-in Functions for Properties</a></li>
<li><a href="#sec:built-in-functions-for-any-model-element-and-components"><span class="toc-section-number">6.4</span> Built-in Functions for Any Model Element and Components</a></li>
<li><a href="#sec:built-in-functions-for-features"><span class="toc-section-number">6.5</span> Built-in Functions for Features</a></li>
<li><a href="#sec:built-in-functions-for-connections"><span class="toc-section-number">6.6</span> Built-in Functions for Connections</a></li>
<li><a href="#sec:built-in-functions-for-bindings"><span class="toc-section-number">6.7</span> Built-in Functions for Bindings</a></li>
<li><a href="#sec:built-in-functions-for-sets-and-lists"><span class="toc-section-number">6.8</span> Built-in Functions for Sets and Lists</a></li>
<li><a href="#sec:built-in-functions-for-flows"><span class="toc-section-number">6.9</span> Built-in Functions for Flows</a></li>
<li><a href="#sec:built-in-functions-for-error-models"><span class="toc-section-number">6.10</span> Built-in Functions for Error Models</a></li>
<li><a href="#sec:external-functions"><span class="toc-section-number">6.11</span> External Functions</a></li>
<li><a href="#sec:debug-functions"><span class="toc-section-number">6.12</span> Debug Functions</a></li>
</ul></li>
<li><a href="#sec:common-resolute-function-library"><span class="toc-section-number">7</span> Common Resolute Function Library</a><ul>
<li><a href="#sec:binding-related-functions"><span class="toc-section-number">7.1</span> Binding Related Functions</a></li>
<li><a href="#sec:connection-related-functions"><span class="toc-section-number">7.2</span> Connection Related Functions</a></li>
<li><a href="#sec:model-element-containment"><span class="toc-section-number">7.3</span> Model Element Containment</a></li>
<li><a href="#sec:handling-of-feature-groups"><span class="toc-section-number">7.4</span> Handling of Feature Groups</a></li>
</ul></li>
<li><a href="#sec:resolute-examples"><span class="toc-section-number">8</span> Resolute Examples</a><ul>
<li><a href="#sec:debugging-models-with-resolute"><span class="toc-section-number">8.1</span> Debugging Models with Resolute</a></li>
<li><a href="#sec:reachable-model-elements"><span class="toc-section-number">8.2</span> Reachable Model Elements</a></li>
</ul></li>
<li><a href="#sec:copyright"><span class="toc-section-number">9</span> Copyright</a></li>
</ul>
</nav>
<p><span id="introduction"></span></p>
<h1 id="sec:introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>Resolute claim functions, computational functions, and global constants are defined in Resolute annex libraries, <em>i.e.</em>, Resolute annex clauses placed directly in an AADL package.</p>
<pre caption="Resolute Claim Functions"><code>package BudgetCase
public

annex Resolute {**
    MaximumWeight : real = 1.2kg

    SCSReq1(self : component) &lt;=
    ** &quot;R1&quot; SCS shall be no heavier than &quot; MaximumWeight%kg **
    SCSReq1VA1(self, MaximumWeight) or SCSReq1VA2(self, MaximumWeight)

    AddBudgets(self : component) : real =
    sum([WeightBudget(t) for (t: subcomponents(self))])</code></pre>
<p>A claim function can be associated with component implementations by <code>prove</code> statements declared in a Resolute annex subclause. The example shows the <code>prove</code> statement for a claim function <code>SCSReq1</code> with the component itself passed in as a parameter.</p>
<pre caption="Prove Statement for a Claim Function"><code>system implementation SCS.Phys
    subcomponents
        sensor1: device sensor;
        sensor2: device sensor;
        actuator: device actuator;
    annex Resolute {**
        prove (SCSReq1(this))</code></pre>
<p>Invoke the <em>Resolute</em> command on a component implementation. This results in an instantiation of the component implementation and the application of all claim functions associated with all of the components in the instance model via the <code>prove</code> statements.</p>
<figure>
<img src="images/PackagePublic.png" alt="Instantiation from OSATE menu" /><figcaption>Instantiation from OSATE menu</figcaption>
</figure>
<p>The verification results are then displayed in a view labeled <em>Assurance Case.</em></p>
<figure>
<img src="images/AssuranceCaseView.png" alt="Assurance Case Tree View" /><figcaption>Assurance Case Tree View</figcaption>
</figure>
<p><span id="claim-functions"></span></p>
<h1 id="sec:claim-functions"><span class="header-section-number">2</span> Claim Functions</h1>
<p>The syntax of a claim function is as follows:</p>
<pre class="bnf" caption="Claim Function Syntax"><code>&lt;Claim_Function&gt; ::=

    &lt;name&gt; &quot;(&quot; (&lt;parameter&gt; (&quot;,&quot; &lt;parameter) )* )? &quot;)&quot; &quot;&lt;=&quot;
    &quot;**&quot; &lt;description&gt; &quot;**&quot; &lt;claim_function_expression&gt;

&lt;parameter&gt; ::= &lt;name&gt; &quot;:&quot; &lt;type&gt;

&lt;description&gt; ::= &lt;text&gt; ( &lt;parameter_reference&gt; | &lt;text&gt;)*</code></pre>
<p>The parameter declaration consists of a name and a type (see Resolute Type System).</p>
<p>The description for a claim function consists of a sequence of strings and references to claim function parameters, global constants, or local constants (defined by <code>let</code> statements). If your values are numerical with a unit, you can specify the unit to be used for display by indicating the desired unit after a <code>%</code>, <em>e.g.</em>, WeightLimit%kg. The units are those defined by Units property types in property sets and do not have to be qualified by the Units type.</p>
<p>The claim function expression is assumed to be a logical expression (<code>and</code>, <code>or</code>, <code>andthen</code>, <code>orelse</code>, implies (<code>=&gt;</code>)) or quantified expressions (<code>forall</code>,<code>exists</code>) to represent a predicate. You can also and <code>let</code> expressions to compute local variables.</p>
<p>In the case of <code>and</code>, <code>or</code> and <code>forall</code>, all expression elements are executed and then the result is evaluated and returns true only if all claim functions return true. Executing all claim functions allows Resolute to inform the user of all failing claim functions rather than not executing the remaining claim function calls after a failing claim in the case of <code>and</code> and <code>forall</code> and after a successful claim in the case of <code>or</code>.</p>
<p><code>andthen</code> conditionally executes the second operand if the first one is true, i.e., the first operand acts as a precondition to the second one. This is useful when checking that a property exists (<code>has_property</code>) before retrieving it (<code>property</code>) as <code>property</code> throws an exception when the value is not found.</p>
<p><code>orelse</code> conditionally executes the second operand as an alternative if the first one is false. For example, this is useful when a predicate is evaluated in a compute function and if it returns false we want to provide an explanatory message using <code>fail</code>.</p>
<p><code>exists</code> will execute elements in the provided collection until one evaluates to true. Note that provided collections are not always in the order you expect, e.g., <code>subcomponents(c)</code> returns a collection that is ordered by component name, not the declaration order.</p>
<p><code>=&gt;</code> only executes the second operand if the first one is true. Note, however that if the left operand is false the result of <code>=&gt;</code> is true without execute the right operand.</p>
<p>A Resolute annex library is declared directly in a package through the <code>annex</code> Resolute <code>{**</code> <em>&lt;library content&gt;</em> <code>**};</code> statement. Typically you want to place a Resolute library in a package by itself - separate from component declarations.</p>
<p>Resolute assumes that there is a global name space for the names of claim functions and computational functions. Therefore, their names must be globally unique. Claim and computational functions can be referenced in <code>prove</code> statements, other claim functions, or computational functions without qualification by a package name.</p>
<blockquote>
<p>You may have two claim functions with the same name in different packages. Resolute will not complain and will use the first one it encounters when resolving references.</p>
</blockquote>
<p><span id="application-of-claim-functions"></span></p>
<h2 id="sec:application-of-claim-functions"><span class="header-section-number">2.1</span> Application of Claim Functions</h2>
<p>Claim functions are invoked on a component by specifying a <code>prove</code> statement in a Resolute annex subclause of the component implementation. This claim function is then executed on every instance of this component implementation when the <em>Resolute</em> command is invoked.</p>
<p>A component implementation can contain multiple <code>prove</code> statements.</p>
<pre class="bnf" caption="Multiple Prove Statements"><code>&lt;Resolute_subclause&gt; :== &quot;annex&quot; &quot;resolute&quot; &quot;{**&quot; &lt;prove_statement&gt; ( &lt;prove_statement&gt; )* &quot;**}&quot; &quot;;&quot;

&lt;prove_statement&gt; ::= &quot;prove&quot; &quot;(&quot; &lt;claim_function_invocation&gt; &quot;)&quot;

&lt;claim_function_invocation&gt; ::= &lt;claim_function_name&gt; &quot;(&quot;
    ( &lt;parameter_value&gt; (&quot;,&quot; &lt;parameter_value&gt;)* )? &quot;)&quot;</code></pre>
<p>The parameter values can be integers, real numbers, strings, Boolean literals, model elements, references to global constants, and collections of these types. They must match the specified type for the parameter.</p>
<p>One special model element reference is expressed by the keyword <code>this</code>. It refers to the instance model object of the model element that contains the <code>prove</code> statement. This is the root object of an instance model as Resolute create a separate instance model every time it encounters a prove statement.</p>
<pre><code>prove ( Memory_safe ( this ))</code></pre>
<p>You can also identify a subcomponent of <code>this</code>; <em>i.e.</em>, associate the verification action with a component down a path of the architecture hierarchy. This allows you to specify a verification action for a specific component instance. This example shows how a <code>prove</code> statement is applied to a subcomponent called subsystem1:</p>
<pre><code>prove (Fully_Connected ( this.subsystem1 ))</code></pre>
<blockquote>
<p>The keyword <code>this</code> can only be used in the <code>prove</code> statement --- not in claim functions or compute functions. Inside claim or compute function you can access elements of the instance model through set constructors such as <code>component</code> or <code>thread</code>.</p>
</blockquote>
<p>The <code>prove</code> statement can be associated with the component classifier of the subcomponent. In that case, it applies to all instances of that component. We recommend that you associate <code>prove</code> statements with a path only if the <code>prove</code> is intended for that particular instance of a subcomponent.</p>
<p><span id="uses-of-claim-functions"></span></p>
<h2 id="sec:uses-of-claim-functions"><span class="header-section-number">2.2</span> Uses of Claim Functions</h2>
<p>The compiler does enforce that claim functions can be invoked only in <code>prove</code> statements, and in other claim functions, and cannot be invoked in computational functions.</p>
<p><span id="computational-functions-and-constants"></span></p>
<h1 id="sec:computational-functions-and-constants"><span class="header-section-number">3</span> Computational Functions and Constants</h1>
<p><span id="computational-functions"></span></p>
<h2 id="sec:computational-functions"><span class="header-section-number">3.1</span> Computational Functions</h2>
<p>Computational functions are used to calculate a value of any type. The result can be Boolean, numeric, model elements, or collections of items of a specific type. Computational functions take parameters that are typed. Computational functions have a single expression that can be preceded by a local constant declaration.</p>
<pre class="bnf" caption="Computational Functions"><code>&lt;computational_function&gt; ::=
    &lt;function_name&gt; &quot;(&quot; &lt;parameter&gt; (&quot;.&quot; &lt;parameter&gt;)* &quot;)&quot; &quot;:&quot; &lt;return_type&gt; &quot;=&quot;
    &lt;computational_expression&gt;</code></pre>
<ul>
<li>Computational functions are defined in Resolute libraries.</li>
<li>Computational functions can be invoked in expressions of claim functions. Typically they are invoked in claim functions that represent verification actions or assumptions.</li>
</ul>
<p><span id="global-constants"></span></p>
<h2 id="sec:global-constants"><span class="header-section-number">3.2</span> Global Constants</h2>
<p>Global constants represent parameters to the verification whose value is set once and can be used in any computational expression, including parameters to claim function calls. Global constants can also hold the result of a computational function or a set constructor whose value can be determined at startup time of a Resolute command. For example, a global constant may be used to precompute various sets of model element instances, <em>e.g.</em>, all elements that are reachable from a component of a certain component type.</p>
<pre class="bnf" caption="Global Constants"><code>&lt;global_constant&gt; ::=
    &lt;constant_name&gt; &quot;:&quot; &lt;type&gt; &quot;=&quot; &lt;computational_expression&gt;</code></pre>
<ul>
<li>Global constants are defined in Resolute libraries.</li>
<li>Global constants can precompute any expression.</li>
</ul>
<p><span id="local-constants"></span></p>
<h2 id="sec:local-constants"><span class="header-section-number">3.3</span> Local Constants</h2>
<p>Resolute also supports precomputation of local constants, which are used inside a claim function or computational function. One or more local constants can be defined before any expression. Typically, they are used in a verification action or computational function before the logical or computational expression. However, they can also be used before any subexpression, <em>e.g.</em>, before the right-hand subexpression of an <code>and</code> or <code>+</code> operator.</p>
<pre class="bnf" caption="Local Constants"><code>&lt;local_constant&gt; ::=
    &quot;let&quot; &lt;constant_name&gt; &quot;:&quot; &lt;type&gt; &quot;=&quot; &lt;computational_expression&gt; &quot;;&quot;</code></pre>
<ul>
<li>The scope of a local constant is the expression; <em>i.e.</em>, they can be referenced only from within the succeeding expression.</li>
<li>Local constants are used to precompute values that may be referenced multiple times in the succeeding expression.</li>
</ul>
<p><span id="predicate-expressions-and-computational-expressions"></span></p>
<h1 id="sec:predicate-expressions-and-computational-expressions"><span class="header-section-number">4</span> Predicate Expressions and Computational Expressions</h1>
<p>A constraint expression results in a Boolean value.</p>
<p><span id="predicate-expressions"></span></p>
<h2 id="sec:predicate-expressions"><span class="header-section-number">4.1</span> Predicate Expressions</h2>
<p>Predicate expressions support the following operators in increasing precedence order:</p>
<p>Logical operators (the operands a, b are expressions of type Boolean):</p>
<ul>
<li>a <code>=&gt;</code> b</li>
<li>a <code>or</code> b <em>and</em> a <code>orelse</code> b</li>
<li>a <code>and</code> b <em>and</em> a <code>andthen</code> b</li>
<li>Negation: <code>not</code> a</li>
<li>Quantified logical expressions: ( <code>forall</code> | <code>exists</code> ) <code>(</code> &lt;variablename&gt; <code>:</code> &lt;collection_constructor&gt; <code>)</code> <code>.</code> &lt;logical_expression&gt;</li>
</ul>
<p><span id="computational-expressions"></span></p>
<h2 id="sec:computational-expressions"><span class="header-section-number">4.2</span> Computational Expressions</h2>
<p>Computational expressions are used in computational functions and must return a value of the specified type. Computational expressions include constraint expressions, arithmetic expressions, and operations on collections of values and model elements.</p>
<p>Relational operators (the operands are of type <code>real</code> or <code>int</code>):</p>
<ul>
<li><code>&lt;</code> | <code>&lt;=</code> | <code>&gt;</code> | <code>&gt;=</code> | <code>=</code> | <code>&lt;&gt;</code></li>
</ul>
<p>Arithmetic operators (the operands are of type <code>real</code> or <code>int</code> and may include a unit):</p>
<ul>
<li><code>+</code> | <code>-</code></li>
<li><code>*</code> | <code>/</code></li>
<li><p>exponent: <code>^</code></p></li>
<li>Negation: <code>-</code> a</li>
<li><p>Precedence brackets: <code>(</code> a <code>)</code></p></li>
</ul>
<blockquote>
<p>The precedence order is Relational operators (low) to Arithmetic in increasing order. They are higher than <code>and</code> <em>and</em> <code>andthen</code>.</p>
</blockquote>
<h3 id="sec:type-related-operators"><span class="header-section-number">4.2.1</span> Type-related operators</h3>
<ul>
<li>Type cast: <code>(</code> &lt;type&gt; <code>)</code> a</li>
</ul>
<blockquote>
<p>Type cast is the same precedence as <code>not</code> <em>and</em> &lt;negations&gt;.</p>
</blockquote>
<h3 id="sec:atomic-expressions"><span class="header-section-number">4.2.2</span> Atomic expressions</h3>
<p>Atomic expressions can be used as operands and have highest precedence.</p>
<ul>
<li><p>Base type values: integer value, real value, string value, and Boolean value. Integer and real values can be annotated with a unit. Any unit defined by a Unit property type in any of the property sets is acceptable.</p></li>
<li><p>Global and local constant reference and parameter reference by their identifier</p></li>
<li><p>Computational function invocation:<br />
function_name <code>(</code> (&lt;parameter_value&gt; ( <code>,</code> &lt;parameter_value&gt; )* )? <code>)</code></p></li>
<li><p>Conditional value: <code>if</code> condition <code>then</code> expression <code>else</code> expression</p></li>
<li><p>Qualified AADL classifier or property definition: ( &lt;ID&gt; <code>::</code> ) *&lt;ID&gt; ( <code>.</code> &lt;ID&gt; )?</p>
<ul>
<li>Classifier used only as a parameter to <code>instance</code> or <code>instances</code> and property definition only in <code>property</code> built-in function</li>
</ul></li>
<li><p>Instance model reference: <code>this</code> ( <code>.</code> &lt;ID&gt; ) *</p>
<ul>
<li>Used only as parameter in <code>prove</code> statement</li>
</ul></li>
</ul>
<h3 id="sec:collection-related-operators"><span class="header-section-number">4.2.3</span> Collection-related operators</h3>
<p>Collections in Resolute can be either lists or sets. Lists can contain multiple identical elements, preserve insertion order, and support <code>head</code> and <code>tail</code> accessors for defining recursive processing. By contrast sets can contain no more than one element of a given value, do not necessarily support insertion order, and support set <code>intersect</code> and <code>union</code> operators. Both lists and sets support quantifiers <code>forall</code> and <code>exists</code> and filtered collections. Operators exist to convert a list into a set (collapsing duplicated elements) and a set into a list.</p>
<ul>
<li><p>Basic collection: &lt;Basic_list&gt; | &lt;Basic_set&gt;</p></li>
<li><p>Basic list: <code>[</code> &lt;expression&gt; ( <code>,</code> &lt;expression&gt; )* <code>]</code> | <code>[ ]</code></p></li>
<li><p>Basic set: <code>{</code> &lt;expression&gt; ( <code>,</code> &lt;expression&gt; )* <code>}</code> | <code>{ }</code></p></li>
<li><p>Filtered collection: &lt;Filterd list&gt; | &lt;Filtered set&gt;</p></li>
<li><p>Filtered list: <code>[</code> &lt;filtered_element&gt; <code>for</code> ( <code>(</code> &lt;element_name&gt; <code>:</code> &lt;collection_constructor&gt; <code>)</code> + ) ( <code>|</code> &lt;filter_expression&gt; )? <code>]</code></p></li>
<li>Filtered set: <code>{</code> &lt;filtered_element&gt; <code>for</code> ( <code>(</code> &lt;element_name&gt; <code>:</code> &lt;collection_constructor&gt; <code>)</code> + ) ( <code>|</code> &lt;filter_expression&gt; )? <code>}</code>
<ul>
<li>Note: &lt;filtered_element&gt; refers to one of the set element names</li>
<li>Note: &lt;filter_expression&gt; is of type Boolean</li>
</ul></li>
</ul>
<pre class="bnf" caption="Collection-Related Operators"><code>&lt;collection_constructor&gt; ::=
    &lt;basic_collection&gt; | &lt;filtered_collection&gt; | &lt;AADL_model_element_type&gt; |
    &lt;global_constant&gt; | &lt;local_constant&gt; | &lt;computational_function_invocation&gt;</code></pre>
<p>Note: The constants must have collections as their values, and the invoked function must return a collection. Function invocations returning a collection can be a user-defined computational function or a built-in function (see Built-in Base Types). The <em>constant reference</em> has to be of a collection type.</p>
<p>The following examples illustrate the use of collections. The first example uses the built-in <code>subcomponents</code> function to get a collection of subcomponents. The <code>forall</code> then iterates over the (set) collection and executes the built-in <code>has_property</code> constraint function on each element.</p>
<p>In the second example, we precompute the collection of subcomponents and hold on to them with a local constant. We then construct a list of real values of value 1.0 for each subcomponent that satisfies the <code>has_property</code> constraint function, then perform the summation of the resulting <code>real</code> (list) collection, and divide it by the size of the subcomponent collection.</p>
<pre class="resolute" caption="Subcomponent Weight Coverage Example"><code>HasSubcomponentWeightBudget(self:component) : bool =
    forall (sub: subcomponents(self)) . has_property(sub,SEI::GrossWeight)

SubcomponentWeightBudgetCoverage(self:component) : bool =
    let subs : {component} = subcomponents(self);
    (sum([ 1.0 for (sub : subs) | has_property(sub,SEI::GrossWeight)]) / length(subs))</code></pre>
<p>Collections can also be precomputed in global constants. This is useful when you want to make use of certain collections of instance model objects repeatedly. In this example, the global constant declaration <code>MOTORS</code> represents the set of instances of a particular component type.</p>
<pre><code>MOTORS : {component} = instances(PX4IOAR::Motor)</code></pre>
<h3 id="sec:the-fail-expression"><span class="header-section-number">4.2.4</span> The <code>fail</code> expression</h3>
<p>The <code>fail</code> expression can be used in any computational function and can be viewed like an exception that is thrown. It is automatically caught by the closest enclosing claim function, interpreted as a fail of the claim, and reported as a sub-result to the claim function. That is, the <code>fail</code> expression is shown as a failure, and the provided text explains the failure.</p>
<ul>
<li>Exception: <code>fail</code> &lt;string value&gt; or <code>fail **</code> &lt;description&gt; <code>**</code> with the description syntax the same as for claim functions</li>
</ul>
<p><span id="resolute-type-system"></span></p>
<h1 id="sec:resolute-type-system"><span class="header-section-number">5</span> Resolute Type System</h1>
<pre class="bnf" caption="Resolute Type System"><code>&lt;type&gt; ::=
    &lt;list_type&gt; | &lt;set_type&gt; | &lt;base_type&gt; | &lt;AADL_model_element_type&gt;

&lt;list_type&gt; ::= &quot;[&quot; &lt;type&gt; &quot;]

&lt;set_type&gt; ::= &quot;{&quot; &lt;type&gt; &quot;}</code></pre>
<p>The list and set collections allow multiple elements of the same value. In the <em>SubcomponentWeightCoverage</em> example, the collection concept has multiple instances of the value 1.0, and each is counted in the summation.</p>
<p><span id="built-inbase-types"></span></p>
<h2 id="sec:built-in-base-types"><span class="header-section-number">5.1</span> Built-in Base Types</h2>
<p>Base type:</p>
<ul>
<li><code>int</code></li>
<li><code>real</code></li>
<li><code>string</code></li>
<li><code>bool</code></li>
<li><code>range</code></li>
</ul>
<p><span id="arithmetic-with-integers-and-reals"></span></p>
<h2 id="sec:arithmetic-with-integers-and-reals"><span class="header-section-number">5.2</span> Arithmetic with Integers and Reals</h2>
<p><code>int</code> and <code>real</code> --- as well as the min and max of a <code>range</code> --- can be values specified with a measurement unit. Any of the unit literals defined in AADL2 Units property types are acceptable. The Units property type definition specifies the ratios to be used to perform conversion between the units. For <code>int</code> and <code>real</code> values with units, Resolute converts the value to a value relative to the base unit (the first unit defined in the Units type). All arithmetic is performed based on those values. To present results in the description of a claim function of a <code>fail</code> operation, the value is converted to the unit specified in the description specification.</p>
<p>Resolute can retrieve property values with built-in functions. The property values for <code>aadlinteger</code> are mapped into <code>int</code>, <code>aadlreal</code> into <code>real</code>, and <code>range of</code> into <code>range</code>.</p>
<p><span id="aadl-model-element-types"></span></p>
<h2 id="sec:aadl-model-element-types"><span class="header-section-number">5.3</span> AADL Model Element Types</h2>
<p>AADL model element types have an implied type hierarchy. The nesting level indicates this type hierarchy.</p>
<ul>
<li><code>aadl</code> [any AADL model element]
<ul>
<li><code>component</code> [any category of AADL component]
<ul>
<li><code>abstract</code> [AADL abstract component]</li>
<li><code>bus</code></li>
<li><code>data</code></li>
<li><code>device</code></li>
<li><code>memory</code></li>
<li><code>processor</code></li>
<li><code>process</code></li>
<li><code>subprogram</code></li>
<li><code>subprogram_group</code></li>
<li><code>system</code></li>
<li><code>thread</code></li>
<li><code>thread_group</code></li>
<li><code>virtual_bus</code></li>
<li><code>virtual_processor</code></li>
</ul></li>
<li><code>connection</code> [AADL connection instance]</li>
<li><code>property</code> [AADL property definition]</li>
<li><code>feature</code> [any AADL feature]
<ul>
<li><code>port</code> [any AADL port]
<ul>
<li><code>data_port</code></li>
<li><code>event_port</code></li>
<li><code>event_data_port</code></li>
<li><code>feature_group</code></li>
</ul></li>
<li><code>access</code> [any AADL access feature]
<ul>
<li><code>bus_access</code>
<ul>
<li><code>provides_bus_access</code></li>
<li><code>requires_bus_access</code></li>
</ul></li>
<li><code>data_access</code>
<ul>
<li><code>provides_data_access</code></li>
<li><code>requires_data_access</code></li>
</ul></li>
<li><code>subprogram_access</code>
<ul>
<li><code>provides_subprogram_access</code></li>
<li><code>requires_subprorgam_access</code></li>
</ul></li>
<li><code>subprogram_group_access</code>
<ul>
<li><code>provides_subprogram_group_access</code></li>
<li><code>requires_subprogram_group_access</code></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p>Resolute operates on the instance model; <em>i.e.</em>, the model elements represent instances. Built-in collection functions operate on instance model elements or retrieve the set of instances for a given classifier (see Built-in Functions).</p>
<p><span id="built-in-functions"></span></p>
<h1 id="sec:built-in-functions"><span class="header-section-number">6</span> Built-in Functions</h1>
<p><span id="built-in-functions-for-collections"></span></p>
<h2 id="sec:built-in-functions-for-collections"><span class="header-section-number">6.1</span> Built-in Functions for Collections</h2>
<p><code>union</code>(&lt;set&gt;, &lt;set&gt;): set - returns a set collection that is the union of the two inputs</p>
<p><code>intersect</code>(&lt;set&gt;, &lt;set&gt;): set - returns a set collection that is the intersection of the two inputs</p>
<p><code>length</code>(&lt;collection&gt;): int - returns the size of the given set or list collection</p>
<p><code>size</code>(&lt;collection&gt;): int - returns the size of the given set or list collection (same as length)</p>
<p><code>member</code>(&lt;element&gt;, &lt;collection&gt;): Boolean - returns true if the element is a member of the set or list collection</p>
<p><code>sum</code>(&lt;numeric_list&gt;): numeric - calculates the sum of a list collection of integers or a list collection of real</p>
<p><code>head</code>(&lt;list&gt;): type - returns the first element of the list collection</p>
<p><code>tail</code>(&lt;list&gt;): list - returns all but the first element of the list collection</p>
<p><code>append</code>(&lt;list&gt;, &lt;list&gt;): list - returns a list collection that is the concatenation of the two given list collections</p>
<p><code>as_set</code>(&lt;list&gt;): set - returns a set collection containing all of the unique elements contained in the given list collection</p>
<p><code>as_list</code>(&lt;set&gt;): list - returns a list collection containing all of the elements contained in the given set collection</p>
<p><span id="built-in-functions-for-ranges"></span></p>
<h2 id="sec:built-in-functions-for-ranges"><span class="header-section-number">6.2</span> Built-in Functions for Ranges</h2>
<p><code>upper_bound</code>(&lt;range&gt;): numeric - returns the upper bound of the range</p>
<p><code>lower_bound</code>(&lt;range&gt;): numeric - returns the lower bound of the range</p>
<p><span id="built-in-functions-for-properties"></span></p>
<h2 id="sec:built-in-functions-for-properties"><span class="header-section-number">6.3</span> Built-in Functions for Properties</h2>
<p><code>has_property</code>(&lt;named_element&gt;, &lt;property&gt;): Boolean - the named element has the property.</p>
<p><code>property</code>(&lt;named_element&gt;, &lt;property&gt;, &lt;default value&gt;*): value - returns the value of the property. If a default value is supplied, then it is returned if the element does not have the property value. If no default is supplied and the value does not exist, a resolute failure exception is thrown, which is caught by the closest enclosing claim function and interpreted as a fail.</p>
<p><code>property</code>(&lt;property&gt;) value - returns the value of the property constant.</p>
<p><code>property_member</code>(&lt;record_property_value&gt;, &lt;field name&gt;): Boolean - return the value of the record field.</p>
<blockquote>
<p>Note: There is no constructor for record values. To compare a property record value to some actual record value you have to write a function that compares each of the fields. <code>=</code> can be used to compare two property record values.</p>
</blockquote>
<p><code>enumerated_values</code>(&lt;property&gt;): [ &lt;string&gt; ] - return the an ordered set of string values.</p>
<p><span id="built-in-functions-for-any-model-element-and-components"></span></p>
<h2 id="sec:built-in-functions-for-any-model-element-and-components"><span class="header-section-number">6.4</span> Built-in Functions for Any Model Element and Components</h2>
<p><code>name</code>(&lt;named_element&gt;): string - returns the name of the named element</p>
<p><code>has_type</code> (named_element): Boolean - returns true if the named element has a classifier. The named element can be a component, feature, or connection instance. In the case of a connection, the type of the feature is the connection end.</p>
<p><code>type</code>(&lt;named_element&gt;): Classifier - returns the classifier of a component, feature, or connection. In the case of a connection, the type is that of the connection source (if not present the destination) feature. The named element must have a type, otherwise a resolute failure exception is thrown and caught by the closest enclosing claim function.</p>
<p><code>is_of_type</code>(&lt;named_element&gt;, &lt;classifier&gt;): Boolean - true if the named element has the classifier or one of its type extensions. The named element must have a type. The named element can be a component, feature, or connection instance. In the case of a connection, the type of the feature is the connection end.</p>
<p><code>has_parent</code>(&lt;named_element&gt;): Boolean - returns true if the component has an enclosing model element</p>
<p><code>parent</code>(&lt;named_element&gt;): named_element - returns the parent of the named element. The parent must exist.</p>
<p><code>has_member</code>(&lt;component&gt;, &lt;string&gt;): Boolean - true if the component has a member with the specified name (string). Members are features, subcomponents, etc. The component can be a component instance or a component classifier.</p>
<blockquote>
<p>Note: Feature instances representing feature groups can have feature instances as members, but they are not handled by this function. See pre-declared library below for flattening feature instances in feature groups.</p>
</blockquote>
<p><code>is_in_array</code>(&lt;component&gt;): Boolean - returns true if the component instance in in an array, i.e., has an index into the array.</p>
<p><code>has_prototypes</code>(&lt;component&gt;): Boolean - returns true if component classifier contains prototype declarations.</p>
<p><code>has_modes</code>(&lt;component&gt;): Boolean - returns true if component directly contains mode instances.</p>
<p><code>is_procesor</code>(&lt;component&gt;): Boolean - true if the component instance is a processor</p>
<p>Other built-in component category tests are: <code>is_virtual_procesor</code>, <code>is_system</code>, <code>is_bus</code>, <code>is_virtual_bus</code>, <code>is_device</code>, <code>is_memory</code>, <code>is_thread</code>, <code>is_process</code>, <code>is_data</code>, <code>is_subprogram</code>.</p>
<blockquote>
<p>Missing tests (<code>abstract</code>, <code>thread_group</code>, <code>subprogram_group</code>) can be tested by <code>\&lt;object\&gt; instanceof \&lt;aadl model element type\&gt;</code></p>
</blockquote>
<p><span id="built-in-functions-for-features"></span></p>
<h2 id="sec:built-in-functions-for-features"><span class="header-section-number">6.5</span> Built-in Functions for Features</h2>
<p><code>direction</code>(&lt;feature&gt;): string - returns the direction of a feature instance as string (<code>in</code>, <code>out</code>, <code>in out</code>/<code>in_out</code>). Access features do not have direction.</p>
<p><code>is_event_port</code>(&lt;feature&gt;): Boolean - true if the feature instance is an event port or event data port</p>
<p><code>is_data_port</code>(&lt;feature&gt;): Boolean - true if the feature instance is an data port or event data port</p>
<p><code>is_port</code>(&lt;feature&gt;): Boolean - true if the feature instance is a port</p>
<p><code>is_abstract_feature</code>(&lt;feature&gt;): Boolean - true if the feature instance is an abstract feature</p>
<blockquote>
<p>Note that you can test any feature or component by writing <code>\&lt;object\&gt; instanceof \&lt;aadl model element type\&gt;</code></p>
</blockquote>
<p><span id="built-in-functions-for-connections"></span></p>
<h2 id="sec:built-in-functions-for-connections"><span class="header-section-number">6.6</span> Built-in Functions for Connections</h2>
<p><code>source</code>(&lt;connection&gt;): connection_endpoint - returns the component or feature instance that is the source of the connection instance</p>
<p><code>destination</code>(&lt;connection&gt;): connection_endpoint - returns the component or feature instance that is the destination of the connection instance</p>
<p><code>is_data_access</code>(&lt;connection&gt;): Boolean - true if one end of a connection is a data component</p>
<p><span id="built-in-functions-for-bindings"></span></p>
<h2 id="sec:built-in-functions-for-bindings"><span class="header-section-number">6.7</span> Built-in Functions for Bindings</h2>
<p><code>is_bound_to</code>(&lt;binding_source&gt;, &lt;binding_target&gt;): Boolean - true if the binding source (a component or connection instance) is bound to the binding target (a component). It handles processor bindings, memory bindings, and connection bindings.</p>
<blockquote>
<p>Note: The <code>is_bound_to</code> function is the same as library function <code>bound</code>.</p>
</blockquote>
<blockquote>
<p>Note: The <code>is_bound_to</code> function does not consider function_bindings. See <em>Resolute_Stdlib.aadl</em> for how this can be done by mirroring <em>processor_bound</em>.</p>
</blockquote>
<p><span id="built-in-functions-for-sets-and-lists"></span></p>
<h2 id="sec:built-in-functions-for-sets-and-lists"><span class="header-section-number">6.8</span> Built-in Functions for Sets and Lists</h2>
<p>Resolute operates on the instance model; this means that the collections are of instance model elements.</p>
<p><code>features</code>(&lt;named_element&gt;): {feature} - returns a collection containing the features of the named element</p>
<p><code>subcomponents</code>(&lt;named_element&gt;): {component} - returns a collection containing the subcomponents (component instances) of the named element</p>
<p><code>connections</code>(&lt;named_element&gt;): {connection} - returns a collection of connection instances for which the named element is an end point (source or destination). The named element can be a component instance or a feature instance.</p>
<p><code>instances</code> (&lt;component_classifier&gt;): {component} - returns the collection of instances in the instance model for a given component classifier</p>
<p><code>instance</code> (&lt;component_classifier&gt;): component - returns the component instance for a given component classifier. The method assumes that there is only one instance.</p>
<p><span id="built-in-functions-for-flows"></span></p>
<h2 id="sec:built-in-functions-for-flows"><span class="header-section-number">6.9</span> Built-in Functions for Flows</h2>
<p><code>end_to_end_flows</code> (&lt;component&gt;): { &lt;end_to_end_flow&gt; } - returns set of end to end flows contained in component instance.</p>
<p><code>flow_elements</code> (&lt;end_to_end_flow&gt;): { &lt;flow_element&gt; } - returns set of flow elements, which are connection instances, flow spec instances, or components instances.</p>
<p><code>flow_specifications</code> (&lt;component&gt;): { &lt;flow_spec&gt; } - returns set of flow specification instances of a component.</p>
<p><code>flow_source</code> (&lt;flow_spec&gt;): feature - returns the source of a flow specification.</p>
<p><code>flow_destination</code> (&lt;flow_spec&gt;): feature - returns the destination of a flow specification.</p>
<p><span id="built-in-functions-for-error-models"></span></p>
<h2 id="sec:built-in-functions-for-error-models"><span class="header-section-number">6.10</span> Built-in Functions for Error Models</h2>
<p><code>error_state_reachable</code> (&lt;component&gt;, &lt;state: string&gt;): Boolean - true</p>
<p><code>propagate_error</code> (&lt;component&gt;, &lt;error_type: string&gt;): Boolean - true if the component instance propagates out the error type on any of its features if the error state of the component instance is reachable by an incoming transition</p>
<p><code>receive_error</code> (&lt;component&gt;, &lt;error_type: string&gt;): Boolean - true true if the component instance receives the error type of a propagated error on any of its features. Not supported yet.</p>
<p><code>contain_error</code> (&lt;component&gt;, &lt;error_type: string&gt;): Boolean - true if the the component instance has an error event with the specified error type. Not supported yet.</p>
<p><span id="external-functions"></span></p>
<h2 id="sec:external-functions"><span class="header-section-number">6.11</span> External Functions</h2>
<p><code>analysis</code> (&lt;function: string&gt;, &lt;args&gt;): &lt;ResoluteValue&gt; - invocation of a Java function registered as an external function extension point. The function is specified as string identifier of the extension point. The arguments are additional parameters of the analysis function.</p>
<p>The return value must be one of the ResoluteValue subclasses: Boolvalue, IntValue, ListValue, NamedElementValue, RangeValue, RealValue, ResoluteRecordValue, SetValue, StringValue.</p>
<p><span id="debug-functions"></span></p>
<h2 id="sec:debug-functions"><span class="header-section-number">6.12</span> Debug Functions</h2>
<p><code>debug</code> (&lt;args&gt;): true - writes one or more arguments (strings and other base types, sets, lists, model elements as names) to the console.</p>
<blockquote>
<p>The debug trace is written to a console in OSATE.</p>
</blockquote>
<blockquote>
<p>You can enable and disable debug tracing through commands in the context menu of the Assurance Case View that comes with Resolute.</p>
</blockquote>
<p><span id="common-resolute-function-library"></span></p>
<h1 id="sec:common-resolute-function-library"><span class="header-section-number">7</span> Common Resolute Function Library</h1>
<p><span id="binding-related-functions"></span></p>
<h2 id="sec:binding-related-functions"><span class="header-section-number">7.1</span> Binding Related Functions</h2>
<p><code>bound</code>(&lt;component, binding_target&gt;): Boolean - true if the component instance is bound to the binding target by actual processor, memory, or connection binding. Note: <code>bound</code> is the same as the built-in <code>is_bound_to</code> function.</p>
<p><code>processor_bound</code>(&lt;component&gt;, &lt;binding_target&gt;): Boolean - true if the component instance is bound to the binding target by actual processor binding</p>
<p><code>memory_bound</code>(&lt;component&gt;, &lt;binding_target&gt;): Boolean - true if the component instance is bound to the binding target by actual memory binding</p>
<p><code>connection_bound</code>(&lt;component&gt;, &lt;binding_target&gt;): Boolean - true if the component instance is bound to the binding target by actual connection binding.</p>
<blockquote>
<p>Note: You may want to implement a <code>function_bound</code> function. See <em>Resolute_Stdlib.aadl</em> for how this can be done by mirroring <em>processor_bound</em>.</p>
</blockquote>
<p><span id="connection-related-functions"></span></p>
<h2 id="sec:connection-related-functions"><span class="header-section-number">7.2</span> Connection Related Functions</h2>
<p><code>connected</code>(&lt;source component&gt;, &lt;connection&gt;, &lt;destination component&gt;): Boolean - returns true if the components are the soruce and destination components of the connection..</p>
<p><code>source_component</code>(&lt;connection&gt;): component - returns the component that is the source of the connection instance. This component contains the feature instance as a connection end point.</p>
<p><code>destination_component</code>(&lt;connection&gt;): component - returns the component that is the destination of the connection instance. This component contains the feature instance as a connection end point.</p>
<p><code>is_port_connection</code>(&lt;connection&gt;): Boolean - true if the connection is a connection between ports</p>
<p><code>is_data_port_connection</code>(&lt;connection&gt;): Boolean - true if one of the connection end points is a data port. Note: should be determined by the destination.</p>
<p><code>is_event_port_connection</code>({connection&gt;): Boolean - true if one of the connection end points is an event port. Note: should be determined by the destination.</p>
<p><code>is_event_data_port_connection</code>(&lt;connection&gt;): Boolean - true if one of the connection end points is an event data port. Note: should be determined by the destination.</p>
<p><code>is_data_access_connection</code>(&lt;connection&gt;): Boolean - true if one of the connection end points is a data access feature.</p>
<p><span id="model-element-containment"></span></p>
<h2 id="sec:model-element-containment"><span class="header-section-number">7.3</span> Model Element Containment</h2>
<p><code>contained</code>(&lt;named_element&gt;, &lt;container_component&gt;): Boolean - true if the named element is contained in the container component. The named element can be a component or feature instance. Note: also works for connection instance.</p>
<p><code>containing_component</code>(&lt;named_element&gt;): component - returns the directly containing component instance. The named element can be a component or feature instance. Note: also works for connection instance.</p>
<p><span id="handling-of-feature-groups"></span></p>
<h2 id="sec:handling-of-feature-groups"><span class="header-section-number">7.4</span> Handling of Feature Groups</h2>
<p>Feature groups are represented in the instance model as a hierarchy of feature instances reflecting the nesting of the feature group.</p>
<p><code>flatten_feature</code>(&lt;feature&gt;): {feature} - returns a set of feature instances that are the leaf elements of a given feature instance. If no elements are contained in the feature instance, the feature instance itself is returned as a set.</p>
<p><code>flatten_features</code>( &lt;{feature}&gt; ) : {feature} - returns a set of feature instances that are the leaf elements of a given feature instance set.</p>
<p><span id="resolute-examples"></span></p>
<h1 id="sec:resolute-examples"><span class="header-section-number">8</span> Resolute Examples</h1>
<p><span id="debugging-models-with-resolute"></span></p>
<h2 id="sec:debugging-models-with-resolute"><span class="header-section-number">8.1</span> Debugging Models with Resolute</h2>
<p>Get a model element trace on the Console View. You enable and disable console logging through a command in the context menu of the Assurance Case View of Resolute. Once enabled the built-in function <strong>debug</strong> will write to the console when executed.</p>
<p>The built-in function <strong>debug</strong> takes one or more parameters and writes them out. It can handle any Resolute base type, lists and sets, as well as AADL model elements.</p>
<pre class="resolute" caption="Model Element Trace in the Assurance View"><code>    let conns : {connection} = connections;
    debug( &quot;Set of connections &quot;,conns)</code></pre>
<p>Get a trace recorded as a result object in the Assurance Case View of Resolute we use claims functions as the examples shown below :</p>
<pre class="resolute" caption="Model Element Trace in the Assurance View"><code>
-- record a model element in the result structure
record_aadl(a : aadl) &lt;=
    ** a **
    true

-- record a set of model elements in the result structure
record_set(s : {aadl}) &lt;=
    ** s **
    true

-- record a list of model elements in the result structure
record_list(s : [aadl], msg: string) &lt;=
     ** msg &quot;: &quot;s **
     true</code></pre>
<p><span id="reachable-model-elements"></span></p>
<h2 id="sec:reachable-model-elements"><span class="header-section-number">8.2</span> Reachable Model Elements</h2>
<p>This is a set of functions that collect AADL components that are directly or indirectly reachable via connections.</p>
<pre class="resolute" caption="Reachability Example"><code>-- return set of reachable components that have no outgoing connections. 
reachable_endpoints(c : component) : {component} =
      let outconns: {connection} = outgoing_component_connections(c);
      if  outconns = {}
      then {c} 
      else  
        {c2 for (conn : outconns) (c2 : reachable_endpoints(destination_component(conn)))}


-- all components that are reachable via port or data access connections from the given component
-- we consider direct and indirect reachability
-- the use of a set ensures that we do not recurse forever
all_reachable_components(c : component) : {component} =
    recusive_reach({c})

-- support method to expand on a set of reachable components by the next directly rachable components
-- the use of a set ensures that we do not recurse forever
recusive_reach(curr: {component}) : {component} =
    let next_ones : {component} = {y for (x : curr) (y : directly_reachable_components(x))};
    let next_new_ones : {component} = {ele for (ele : next_ones)| not(member(ele,curr))};
    if (next_new_ones = {} ) then
        curr
    else 
        union(curr, recusive_reach(next_new_ones))


    -- return set of components that are directly reachable via outgoing connections.
    directly_reachable_components(comp: component):{component} =
    let outconns : {connection} = outgoing_component_connections(comp);
    {otherend for (conn: outconns) (otherend: other_connection_end(conn,comp))}

      
    -- return all outgoing connections
    -- in the case of data access conneciton we need to consider acces rights to determine the direction
    -- in the case of port connecitons we need to filter out in/out ports with incoming connections.
    outgoing_component_connections(comp: component): {connection} =
    { conn for (conn: connections(comp)) | 
        if (is_access_connection(conn)) then
        -- access feature has write access
            source(conn) instanceof access and has_write_access(source(conn)) or 
            destination(conn) instanceof access and has_write_access(destination(conn)) 
        else
        -- we have a directed feature connection
        -- it is not an incoming connection with the source an out only feature
            not(destination_component(conn) = comp 
            and direction((feature)source(conn)) = &quot;out&quot;
        )}

   -- For a given connection and a given component return the component on the other end of the connection
   -- This funciton is useful to deal with access connections or bi-directional port connections
   -- where the source could be either end.
   other_connection_end(conn: connection,comp: component): component =
        if (destination_component(conn) = comp) 
        then
            source_component(conn)
        else
            destination_component(conn)
</code></pre>
<p><span id="copyright"></span></p>
<h1 id="sec:copyright"><span class="header-section-number">9</span> Copyright</h1>
<p>Copyright 2015-18 Carnegie Mellon University</p>
<p>This material is based upon work funded and supported by the Department of Defense under Contract No. FA8721-05-C-0003 with Carnegie Mellon University for the operation of the Software Engineering Institute, a federally funded research and development center.</p>
<p>Any opinions, findings and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the United States Department of Defense.</p>
<p>NO WARRANTY. THIS CARNEGIE MELLON UNIVERSITY AND SOFTWARE ENGINEERING INSTITUTE MATERIAL IS FURNISHED ON AN &quot;AS-IS&quot; BASIS. CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER EXPRESSED OR IMPLIED, AS TO ANY MATTER INCLUDING, BUT NOT LIMITED TO, WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY, OR RESULTS OBTAINED FROM USE OF THE MATERIAL. CARNEGIE MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND WITH RESPECT TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT INFRINGEMENT.</p>
<p>This material has been approved for public release and unlimited distribution.</p>
<p>DM-0002203</p>
</body>
</html>
