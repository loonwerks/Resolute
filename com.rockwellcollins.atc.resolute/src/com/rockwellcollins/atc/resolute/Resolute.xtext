grammar com.rockwellcollins.atc.resolute.Resolute with org.osate.xtext.aadl2.properties.Properties

generate resolute "http://www.rockwellcollins.com/atc/resolute/Resolute"

import "http://aadl.info/AADL/2.0" as aadl2

AnnexLibrary returns aadl2::AnnexLibrary:
	ResoluteLibrary
;

AnnexSubclause returns aadl2::AnnexSubclause:
	ResoluteSubclause
;

Namespace returns aadl2::Namespace:
	FunctionDefinition 
;

NamedElement returns aadl2::NamedElement:
	Definition
|	Arg
|   LetBinding
;

Element returns aadl2::Element:
	Expr
| 	AnalysisStatement
|   ClaimText
|   DefinitionBody
;

ResoluteLibrary:
	{ResoluteLibrary}
	definitions+=Definition*
;

Definition:
	ConstantDefinition 
|	FunctionDefinition
|	Ruleset
|	NotationDefinition
;

NotationDefinition:
 	name='notation' notation=Notation
;

Notation:
	'justification' 'pattern' | 'jp' | 'gsn' | 'goal' 'structuring' 'notation'
;

Type:
	{ListType} '[' type=Type ']'
|	{SetType} '{' type=Type '}'
|	BaseType ('<' paramType=Type '>')?
|	{LibraryFnType} libName=ID '.' fnType=ID
;

BaseType:
	type=( 'int'
         | 'real'
         | 'string'
         | 'bool'
         | 'range'
         | 'aadl'
         | 'component'
         | 'abstract'
         | 'bus'
         | 'data'
         | 'device'
         | 'memory'
         | 'processor'
         | 'process'
         | 'subprogram_group'
         | 'subprogram'
         | 'system'
         | 'thread_group'
         | 'thread'
         | 'virtual_bus'
         | 'virtual_processor'
         | 'connection'
         | 'property'
         | 'feature'
         | 'port'
         | 'data_port'
         | 'event_port'
         | 'event_data_port'
         | 'feature_group'
         | 'access'
         | 'bus_access'
         | 'provides_bus_access'
         | 'requires_bus_access'
         | 'data_access'
         | 'provides_data_access'
         | 'requires_data_access'
         | 'subprogram_access'
         | 'provides_subprogram_access'
         | 'requires_subprogram_access'
         | 'subprogram_group_access'
         | 'provides_subprogram_group_access'
         | 'requires_subprogram_group_access'
         | 'flow_specification'
         | 'end_to_end_flow'
         
         // Evidence types
		 // W3C-PROV
		|	'entity'
		|	'agent'
		|	'activity'
		|	'thing'
		 // ANALYSIS
		|	'analysis_activity'	// corresponds to ANALYSIS class, type of activity
		|	'analysis_report' 
		|	'analysis_result' // class, must be one of {Passed, Failed, Indeterminate}
		|	'analysis_annotation_type' // class
		|	'precondition'	// type of analysis_annotation_type
		|	'postcondition'	// type of analysis_annotation_type
		|	'invariant'	// type of analysis_annotation_type
		|	'analysis_annotation' // type of entity
		 // HAZARD
		|	'hazard' // entity
		|	'hazard_identification' // type of activity
		 // REQUIREMENT
		|	'requirement' // type of entity
		|	'data_dictionary_term' // type of entity
		|	'requirement_development' // type of activity
		 // REVIEW
		|	'review' // type of activity
		|	'review_log' // type of entity
		|	'review_state' // class, must be one of {Passed, RevisedWithoutReview, RevisedWithReview}
		 // SOFTWARE
		|	'file' // type of entity
		|	'format' // type of thing
		|	'code_development' // type of activity
		|	'build' // type of activity
		|	'code_gen' // type of activity
		|	'compile' // type of activity
		|	'package_file' // corresponds to PACKAGE, type of activity
		|	'component_type' // type of thing
		|	'source_function' // type of component_type
		|	'binary_function' // type of component_type
		|	'source_global_variable' // type of component_type
		|	'binary_global_variable' // type of component_type
		|	'binary_basic_block' // type of component_type
		|	'class_definition' // type of component_type
		|	'class_method' // type of component_type
		|	'class_member_variable' // type of component_type
		|	'class_constructor' // type of component_type
		|	'module' // type of component_type
		|	'namespace' // type of component_type
//		|	'component' // type of entity
		 // SYSTEM
//		|	'system' // type of entity
		|	'interface' // type of entity
		|	'system_development' // type of activity
		 // TESTING
		|	'test' // type of entity
		|	'test_result' // type of entity
		|	'test_status' // class, must be one of {Passed, Failed, Indeterminate}
		|	'test_developmemt' // type of activity
		|	'test_execution' // type of activity
         );

//Arg types are used for functions, claims, and quantifiers
Arg returns Arg: 
	=>(name=ID ':' type=Type)
|	{QuantArg} name=ID ':' expr=Expr
;

ConstantDefinition:
	name=ID ':' type=Type '=' expr=Expr
;

FunctionDefinition:
	(claimType='goal' | claimType='conclusion' | claimType='strategy')? name=ID '(' (args+=Arg (',' args+=Arg)*)? ')' body=DefinitionBody
;

DefinitionBody:
	 {FunctionBody} ':' type=Type '=' expr=Expr
|	 {ClaimBody} '<=' ('**'(claim+=ClaimText)+'**') (attributes+=ClaimAttribute)* expr=Expr
;

ClaimAttribute returns aadl2::NamedElement:
	ClaimContext
|	ClaimJustification
|	ClaimAssumption
|	ClaimStrategy
|	ClaimUsageDomain
|	ClaimRationale
| 	ClaimRestriction
;

ClaimContext:
	'context' name=ID ':' expr=Expr ';'
;

ClaimUsageDomain:
	'domain' name=ID ':' val=StringTerm ';'
;

ClaimRationale:
	'rationale' name=ID ':' val=StringTerm ';'
;

ClaimRestriction:
	'restriction' name=ID ':' expr=Expr ';'
;

ClaimJustification:
	'justification' name=ID ':' val=StringTerm ';'
;

ClaimAssumption:
	('assumption') name=ID ':' expr=Expr ';'
;

ClaimStrategy:
	'strategy' name=ID ':' val=StringTerm ';' 
;

ClaimText:
	 {ClaimString} str=STRING 
| 	 {ClaimArg} arg=[ClaimTextVar] ('%' unit=[aadl2::UnitLiteral])?
;

ClaimTextVar: Arg | ConstantDefinition | LetBinding | ClaimContext | ClaimAssumption;

Expr:
	ImpliesExpr
;

ImpliesExpr returns Expr:
	OrExpr (=>({BinaryExpr.left=current} op='=>') right=ImpliesExpr)?
;

OrExpr returns Expr:
	AndExpr (=>({BinaryExpr.left=current} (op='or'|op='orelse')) right=AndExpr)*
;

AndExpr returns Expr:
	InstanceOfExpr (=>({BinaryExpr.left=current} (op='and'|op='andthen')) right=InstanceOfExpr)*
;

InstanceOfExpr returns Expr:
	RelationalExpr (=>({InstanceOfExpr.expr=current} 'instanceof') type=BaseType)?
;

RelationalOp:
	'<' | '<=' | '>' | '>=' | '=' | '<>'
;
 
RelationalExpr returns Expr:
	PlusExpr (=>({BinaryExpr.left=current} op=RelationalOp) right=PlusExpr)?
;

PlusExpr returns Expr:
	TimesExpr (=>({BinaryExpr.left=current} op=('+' | '-')) right=TimesExpr)*
;

TimesExpr returns Expr:
	ExpExpr (=>({BinaryExpr.left=current} op=('*' | '/' | '%')) right=ExpExpr)*	
;

ExpExpr returns Expr:
	PrefixExpr (=>({BinaryExpr.left=current} op=('^')) right=PrefixExpr)*
;

PrefixExpr returns Expr:
	{UnaryExpr} op=('-' | 'not') expr=PrefixExpr
|   {CastExpr} '(' type=BaseType ')' expr=PrefixExpr
|	AtomicExpr
;

AtomicExpr returns Expr:
	{IdExpr} id=[aadl2::NamedElement | QCREF]
|	{ThisExpr} 'this' ('.' sub=NestedDotID)?
|   {FailExpr} 'fail' ( val=Expr | ( '**' (failmsg+=ClaimText)+  '**')) 
|	{ResultExpr} result=Result
|	{IntExpr} val=IntegerTerm
|   {RealExpr} val=RealTerm
|	{BoolExpr} val=BooleanLiteral
|   {StringExpr} val=StringTerm
|	{IfThenElseExpr} 'if' cond=Expr 'then' then=Expr 'else' else=Expr
|   {QuantifiedExpr} quant=('forall' | 'exists') ('(' args+=Arg ')')+ '.' expr=Expr
|	=> ({LibraryFnCallExpr} libName=ID '.' fnName=ID '(' (args+=(Expr) (',' args+=(Expr))*)? ')')
|   {BuiltInFnCallExpr} fn=BuiltInFn '(' (args+=(Expr) (',' args+=(Expr))*)? ')'
|	{FnCallExpr} fn=[FunctionDefinition] '(' (args+=(Expr) (',' args+=(Expr))*)? ')'
|	{LintExpr} lintStmt=LintStatement
|   '[' Expr ( ({ListFilterMapExpr.map=current} 'for' ('(' args+=Arg ')')+ ('|' filter=Expr)?)
             | ({ListExpr.exprs+=current} (',' exprs+=Expr)*)) ']'
|   '{' Expr ( ({SetFilterMapExpr.map=current} 'for' ('(' args+=Arg ')')+ ('|' filter=Expr)?)
             | ({SetExpr.exprs+=current} (',' exprs+=Expr)*)) '}'
|   {ListExpr} '[' ']'
|   {SetExpr} '{' '}'
|   {LetExpr} 'let' binding=LetBinding ';' expr=Expr
|	'(' Expr ')'

| {UndevelopedExpr} 'undeveloped' 
| {EvidenceExpr} 'evidence' name=ID ':' val=StringTerm 
| {SolutionExpr} 'solution' name=ID ':' val=StringTerm 
;

LetBinding:
	name=ID ':' type=Type '=' expr=Expr
;

Result:
	'passed'
|	'failed'
|	'indeterminate'
|	'revised_with_review'
|	'revised_without_review'
;

BuiltInFn:
// Primary type: aadl
	'has_property'
|	'property'
|	'property_member'
|	'has_parent'
|	'parent'
|	'name'
|	'type'
|	'has_type'
|	'is_in_array'
|	'has_prototypes'
|	'has_modes'

|	'is_processor'
|	'is_virtual_processor'
|	'is_system'
|	'is_bus'
|	'is_virtual_bus'
|	'is_device'
|	'is_memory'
|	'is_thread'
|	'is_thread_group'
|	'is_process'
|	'is_data'

|	'is_subprogram'
|   'is_of_type'
|   'is_bound_to'
|	'has_member'
|   'features'
|	'connections'

// Primary type: property
|   'enumerated_values'

// Primary type: component
|	'subcomponents'

// Primary type: connection
|	'source'
|	'destination'
|	'is_bidirectional'

// Primary type: feature
|	'direction'
|	'is_event_port'
|	'is_abstract_feature'
|	'is_data_port'
|	'is_port'
|	'is_data_access'
|	'is_bus_access'

// Primary type: range
|	'lower_bound'
|	'upper_bound'

// Primary type: set or list
|	'member'
|   'length'
| 	'size'

// Primary type: list
|	'sum'
|	'append'
|	'head'
|	'tail'
|	'as_set'

// Primary type: set
|	'union'
|	'intersect'
|	'as_list'

// Other
|	'instance'
|	'instances'
|	'debug'
|	'analysis'

// Error Annex
|	'receive_error'           // the component can receive an incoming error
|	'contain_error'           // the component contain the error
|	'propagate_error'         // the component propagate an error
|   'error_state_reachable'   // the error state is reachable

|   'flow_source'
|   'flow_destination'
|   'flow_elements'
|   'flow_specifications'
|   'end_to_end_flows'

// Evidences
	// ANALYSIS
|	'result_of' // describes ANALYSIS_REPORT, TEST_RESULT with values of type TEST_STATUS
|	'metric' // describes ANALYSIS_REPORT with values of type float
|	'analyzes' // describes ANALYSIS_REPORT with values of type ENTITY
|	'produced_by' // describes ANALYSIS_REPORT, SYSTEM, TEST with values of type ACTIVITY
|	'performed_by' // describes ANALYSIS, CODE_GEN, COMPILE, PACKAGE_FILE with values of type AGENT
|	'from_report' // describes ANALYSIS_ANNOTATION with values of type ENTITY
|	'description' // describes ANALYSIS_ANNOTATION with values of type string
|	'annotation_type' // describes ANALYSIS_ANNOTATION with values of type ANALYSIS_ANNOTATION_TYPE
	// HAZARD
|	'definition' // describes HAZARD with values of type string
|	'source_of' // corresponds to SOURCE, describes HAZARD, INTERFACE with values of type ENTITY
|	'identified' // describes HAZARD with values of type HAZARD_IDENTIFICATION
|	'author' // describes HAZARD_IDENTIFICATION, REQUIREMENT_DEVELOPMENT, REVIEW, CODE_DEVELOPMENT with values of type AGENT
|	'text' // describes REQUIREMENT, DATA_DICTIONARY_TERM with values of type string
|	'given_text' // describes REQUIREMENT with values of type string
|	'if_text' // describes REQUIREMENT with values of type string
|	'then_text' // describes REQUIREMENT with values of type string
|	'governs' // describes REQUIREMENT with values of type ENTITY
|	'satisfies' // describes REQUIREMENT, FILE with values of type ENTITY
|	'mitigates' // describes REQUIREMENT with values of type ENTITY
|	'created_by' // describes REQUIREMENT, DATA_DICTIONARY_TERM, REVIEW_LOG, FILE with values of type ACTIVITY
|	'provided_by' // describes DATA_DICTIONARY_TERM with values of type ENTITY
|	'consumed_by' // describes DATA_DICTIONARY_TERM with values of type ENTITY
|	'referenced' // describes REQUIREMENT_DEVELOPMENT, CODE_DEVELOPMENT with values of type ENTITY
|	'governed_by' // describes REQUIREMENT_DEVELOPMENT, REVIEW, CODE_DEVELOPMENT with values of type ENTITY
	// REVIEW
|	'reviews' // describes REVIEW_LOG with values of type ENTITY
|	'review_result' // describes REVIEW_LOG with values of type REVIEW_STATE
|	'reviewer' // describes REVIEW with values of type AGENT
|	'reviewed' // describes REVIEW with values of type ENTITY
	// SOFTWARE
|	'filename' // describes FILE with values of type string
|	'step' // describes BUILD with values of type ACTIVITY
|	'compiled_by' // describes COMPILE with values of type FILE
|	'compile_input' // describes COMPILE with values of type FILE
|	'packaged_by' // describes PACKAGE_FILE with values of type FILE
|	'package_input' // describes PACKAGE_FILE with values of type FILE
//|	'name' // describes COMPONENT with values of type string
|	'type_of' // corresponds to componentType, describes COMPONENT with a single value of type COMPONENT_TYPE
|	'value_type' // describes COMPONENT with values of type string
|	'instantiates' // describes COMPONENT with values of type ENTITY
|	'defined_in' // describes COMPONENT with values of type ENTITY
|	'mentions' // describes COMPONENT with values of type ENTITY
|	'subcomponent_of' // describes COMPONENT with values of type ENTITY
|	'requirements' // describes COMPONENT with values of type ENTITY
|	'annotations' // describes COMPONENT with values of type ENTITY
|	'control_flows_to_unconditionally' // describes COMPONENT with values of type COMPONENT
|	'control_flows_to_conditionally' // describes COMPONENT with values of type COMPONENT
	// SYSTEM
|	'part_of' // describes SYSTEM with values of type ENTITY
|	'provides' // describes SYSTEM with values of type ENTITY
|	'requires' // describes SYSTEM with values of type ENTITY
|	'destination_of' // describes INTERFACE with values of type ENTITY
|	'identified_by' // describes INTERFACE with values of type ACTIVITY
|	'developed_by' // describes SYSTEM_DEVELOPMENT, TEST_DEVELOPMENT with values of type AGENT
	// TESTING
|	'verifies' // describes TEST with values of type ENTITY
|	'confirms' // describes TEST_RESULT with values of type ENTITY
|	'executed_by' // describes TEST_RESULT with values of type ACTIVITY
|	'executed_on' // describes TEST_EXECUTION with values of type AGENT
;

@Override
RealTerm returns aadl2::RealLiteral:
	value=UnsignedReal (unit=[aadl2::UnitLiteral|ID])?
;

UnsignedReal returns aadl2::Real:
	REAL_LIT
;

@Override
IntegerTerm returns aadl2::IntegerLiteral:
	value=UnsignedInt (unit=[aadl2::UnitLiteral|ID])?
;

UnsignedInt returns aadl2::Integer:
	INTEGER_LIT
;

ResoluteSubclause:
	{ResoluteSubclause}
	proves+=AnalysisStatement*

;

NestedDotID:
	base=[aadl2::NamedElement | ID] ('.' sub=NestedDotID)?
;

LintStatement:
	{WarningStatement} 'warning' expr=Expr
|	{ErrorStatement} 'error' expr=Expr
|	{InfoStatement} 'info' expr=Expr
;

Ruleset:
	'ruleset' name=ID '{' body=RulesetBody '}'
;

RulesetBody:
	{RulesetBody}
	lintStatements+=LintStatement*
;

AnalysisStatement:
	{ProveStatement} 'prove' expr=Expr
|	{CheckStatement} 'check' expr=Expr	
;

